//放苹果，深搜
#include <iostream>
using namespace std;
int m,n,ans,a[11]={1};              //数组a用来记录前i个盘子的苹果数
//深搜的方案是，全局有10个盘子，递归试探到第10个盘子，然后在回溯过程中放空后面的盘子，逐步试探n到1个盘子
//可以通过调试观察a的变化，来理解递归的过程
int f(int s,int k){                 //s表示剩余的苹果数，k表示当前处理的盘子数
    for (int i=a[k-1];i<=s;i++){    //从上一个盘子的苹果数开始遍历，当前第k个盘子放从0到s个苹果
                                    //这个地方很巧妙，用剩下的s和上一个盘子已经放的苹果比较来控制当前盘子的苹果数必须大于等于上一个盘子的苹果数，可以防止重复
        if (i<=m){                  //如果当前已经摆放的苹果数不超过m
            s-=i;                   //减去当前盘子的苹果数
            a[k]=i;                 //记录当前盘子的苹果数
            if(s==0&&k<=n)          //如果所有苹果都放完了，并且盘子数不超过n
                ans++;              //答案加一
            else
                f(s,k+1);           //剩下的s个苹果，继续放下一个盘子
            s+=i;                   //回溯
        }
    }    
    return 0;
}
int main(){
    int k;
    cin>>k;
    for (int i=0;i<k;i++){
        cin>>m>>n;
        ans=0;
        f(m,1);
        cout<<ans<<endl;
    }
    return 0;
}